// Generated by CoffeeScript 1.7.1
(function() {
  var GameOfLife,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  GameOfLife = (function() {
    GameOfLife.prototype.currentCellGeneration = null;

    GameOfLife.prototype.currentGenerationNum = 0;

    GameOfLife.prototype.cellSize = 7;

    GameOfLife.prototype.numberOfRows = 128;

    GameOfLife.prototype.numberOfColumns = 128;

    GameOfLife.prototype.seedProbability = 0.3;

    GameOfLife.prototype.tickLength = 100;

    GameOfLife.prototype.canvas = null;

    GameOfLife.prototype.drawingContext = null;

    GameOfLife.prototype.stopCreteria = null;

    GameOfLife.prototype.liveCreteria = [2, 3];

    GameOfLife.prototype.deadCreteria = [3];

    function GameOfLife() {
      this.tick = __bind(this.tick, this);
      this.createCanvas();
      this.canvas.onmousedown = this.defineImage;
      this.resizeCanvas();
      this.createDrawingContext();
      this.seed();
      this.drawGrid();
    }

    GameOfLife.prototype.createCanvas = function() {
      var temp;
      temp = document.getElementById('canvasPlace');
      this.canvas = document.createElement('canvas');
      this.canvas.clss = this;
      return temp.appendChild(this.canvas);
    };

    GameOfLife.prototype.resizeCanvas = function() {
      this.canvas.height = this.cellSize * this.numberOfRows;
      return this.canvas.width = this.cellSize * this.numberOfColumns;
    };

    GameOfLife.prototype.createDrawingContext = function() {
      return this.drawingContext = this.canvas.getContext('2d');
    };

    GameOfLife.prototype.seed = function() {
      var column, row, seedCell, _i, _ref, _results;
      this.currentCellGeneration = [];
      _results = [];
      for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        this.currentCellGeneration[row] = [];
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
            seedCell = this.createSeedCell(row, column);
            _results1.push(this.currentCellGeneration[row][column] = seedCell);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    GameOfLife.prototype.createSeedCell = function(row, column) {
      return {
        isAlive: Math.random() < this.seedProbability,
        row: row,
        column: column
      };
    };

    GameOfLife.prototype.createCell = function(row, column, isAlive) {
      return {
        isAlive: isAlive,
        row: row,
        column: column
      };
    };

    GameOfLife.prototype.drawGrid = function() {
      var column, row, _i, _ref, _results;
      _results = [];
      for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(this.drawCell(this.currentCellGeneration[row][column]));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    GameOfLife.prototype.drawCell = function(cell) {
      var fillStyle, x, y;
      x = cell.column * this.cellSize;
      y = cell.row * this.cellSize;
      if (cell.isAlive) {
        fillStyle = 'rgb(242, 198, 65)';
      } else {
        fillStyle = 'rgb(38, 38, 38)';
      }
      this.drawingContext.strokeStyle = 'rgba(242, 198, 65, 0.1)';
      this.drawingContext.strokeRect(x, y, this.cellSize, this.cellSize);
      this.drawingContext.fillStyle = fillStyle;
      return this.drawingContext.fillRect(x, y, this.cellSize, this.cellSize);
    };

    GameOfLife.prototype.tick = function() {
      this.drawGrid();
      this.evolveCellGeneration();
      return this.stopCreteria = setTimeout(this.tick, this.tickLength);
    };

    GameOfLife.prototype.stop = function() {
      return clearTimeout(this.stopCreteria);
    };

    GameOfLife.prototype.drawImageText = function(text) {
      var context;
      context = this.canvas.getContext("2d");
      return context.fillRect(text.coords.x, text.coords.y, this.cellSize, this.cellSize);
    };

    GameOfLife.prototype.clearField = function() {
      var i, item, _i, _j, _len, _len1, _ref;
      _ref = this.currentCellGeneration;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        for (_j = 0, _len1 = i.length; _j < _len1; _j++) {
          item = i[_j];
          item.isAlive = false;
        }
      }
      this.drawGrid();
      return this.currentGenerationNum = 0;
    };

    GameOfLife.prototype.defineImage = function(evt) {
      var cell, clss, currentPos, i, j, json, rect;
      rect = this.getBoundingClientRect();
      clss = this.clss;
      currentPos = {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      };
      json = {
        "coords": {
          "x": currentPos.x,
          "y": currentPos.y
        }
      };
      i = Math.floor(currentPos.x / clss.cellSize);
      j = Math.floor(currentPos.y / clss.cellSize);
      cell = clss.createCell(j, i, !clss.currentCellGeneration[j][i].isAlive);
      clss.currentCellGeneration[j][i] = cell;
      return clss.drawCell(cell);
    };

    GameOfLife.prototype.evolveCellGeneration = function() {
      var column, evolvedCell, newCellGeneration, row, _i, _j, _ref, _ref1;
      newCellGeneration = [];
      for (row = _i = 0, _ref = this.numberOfRows; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
        newCellGeneration[row] = [];
        for (column = _j = 0, _ref1 = this.numberOfColumns; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; column = 0 <= _ref1 ? ++_j : --_j) {
          evolvedCell = this.evolveCell(this.currentCellGeneration[row][column]);
          newCellGeneration[row][column] = evolvedCell;
        }
      }
      this.currentGenerationNum++;
      document.getElementById('genNum').innerText = this.currentGenerationNum;
      return this.currentCellGeneration = newCellGeneration;
    };

    GameOfLife.prototype.evolveCell = function(cell) {
      var evolvedCell, i, numberOfAliveNeighbors, _i, _j, _len, _len1, _ref, _ref1;
      evolvedCell = {
        row: cell.row,
        column: cell.column,
        isAlive: false
      };
      numberOfAliveNeighbors = this.countAliveNeighbors(cell);
      if (cell.isAlive) {
        _ref = this.liveCreteria;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          if (i === numberOfAliveNeighbors) {
            evolvedCell.isAlive = true;
            break;
          }
        }
      } else {
        _ref1 = this.deadCreteria;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          i = _ref1[_j];
          if (i === numberOfAliveNeighbors) {
            evolvedCell.isAlive = true;
            break;
          }
        }
      }
      return evolvedCell;
    };

    GameOfLife.prototype.addTrue = function(value) {
      return value = true;
    };

    GameOfLife.prototype.addFalse = function(value) {
      return value = false;
    };

    GameOfLife.prototype.countAliveNeighbors = function(cell) {
      var column, lowerColumnBound, lowerRowBound, numberOfAliveNeighbors, row, upperColumnBound, upperRowBound, _i, _j;
      lowerRowBound = Math.max(cell.row - 1, 0);
      upperRowBound = Math.min(cell.row + 1, this.numberOfRows - 1);
      lowerColumnBound = Math.max(cell.column - 1, 0);
      upperColumnBound = Math.min(cell.column + 1, this.numberOfColumns - 1);
      numberOfAliveNeighbors = 0;
      for (row = _i = lowerRowBound; lowerRowBound <= upperRowBound ? _i <= upperRowBound : _i >= upperRowBound; row = lowerRowBound <= upperRowBound ? ++_i : --_i) {
        for (column = _j = lowerColumnBound; lowerColumnBound <= upperColumnBound ? _j <= upperColumnBound : _j >= upperColumnBound; column = lowerColumnBound <= upperColumnBound ? ++_j : --_j) {
          if (row === cell.row && column === cell.column) {
            continue;
          }
          if (this.currentCellGeneration[row][column].isAlive) {
            numberOfAliveNeighbors++;
          }
        }
      }
      return numberOfAliveNeighbors;
    };

    GameOfLife.prototype.getCurrentPos = function(evt) {
      var rect, result;
      rect = this.canvas.getBoundingClientRect();
      result = JSON.stringify({
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      });
      return result;
    };

    return GameOfLife;

  })();

  window.GameOfLife = GameOfLife;

}).call(this);
